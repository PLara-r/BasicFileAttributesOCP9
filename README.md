# BasicFileAttributesOCP9

Понимание атрибутов файла
В предыдущем разделе мы рассмотрели методы, которые могут создавать, изменять, читать или удалять файл или каталог. FilesКласс также предоставляет множество методов с доступом к файлам и каталогам метаданных, именуемые атрибутам файла . Проще говоря, metadataэто данные, которые описывают другие данные. В этом контексте метаданные файла - это данные о файле или записи каталога в файловой системе, а не содержимое файла.
Например, файл или каталог могут быть скрыты в файловой системе или помечены с разрешением, которое не позволяет текущему пользователю прочитать их. FilesКласс предоставляет методы для определения этой информации из вашего приложения Java.
При чтении метаданных файла в Java нужно помнить, что некоторые методы зависят от операционной системы. Например, некоторые операционные системы могут не иметь представления о правах доступа на уровне пользователя, и в этом случае пользователи могут читать только те файлы, которые у них есть права на чтение.  
Обнаружение основных файловых атрибутов
Мы начнем обсуждение атрибутов файла с представления основных методов, определенных непосредственно в Filesклассе, для чтения атрибутов файла. Эти методы можно использовать в любой файловой системе, хотя они могут иметь ограниченное значение в некоторых файловых системах. В следующем разделе мы представим более обобщенный подход с использованием представлений атрибутов и покажем, что они не только улучшают производительность, но и позволяют нам получать доступ к атрибутам, зависящим от файловой системы. 
 Чтение общих атрибутов с помощью isDirectory () , isRegularFile () и isSymbolicLink ()
FilesКласс включает в себя три метода для определения , если путь указывает на каталог, обычный файл, или символической ссылки. Методы для достижения этой цели были названы Files.isDirectory(Path), Files.isRegularFile(Path)и Files.isSymbolicLink(Path), соответственно.
Java определяет regular fileкак содержащий контент, а не символическую ссылку, каталог, ресурс или другой нестандартный файл, который может присутствовать в некоторых операционных системах. Если символическая ссылка указывает на реальный файл или каталог, Java выполнит проверку цели символической ссылки. Другими словами, можно isRegularFile()вернуть trueсимволическую ссылку, если ссылка преобразуется в обычный файл.
Давайте посмотрим на пример кода:
Files.isDirectory(Paths.get("/canine/coyote/fur.jpg"));
 Files.isRegularFile(Paths.get("/canine/types.txt"));
 Files.isSymbolicLink(Paths.get("/canine/coyote"));

Первый пример возвращает trueif fur.jpgявляется каталогом или символической ссылкой на каталог и т false. Д. Обратите внимание, что каталоги могут иметь расширения во многих файловых системах, поэтому это может fur.jpgбыть имя каталога. Второй пример возвращает trueif, types.txtуказывающий на обычный файл или, альтернативно, на символическую ссылку, которая указывает на обычный файл. Третий пример возвращает trueif /canine/coyoteявляется символической ссылкой, независимо от того, существует ли файл или каталог, на который он указывает.
Мы освещаем эти понятия в таблице 9.3 . Для этой таблицы предположим, что файловая система с каталогом /canine/coyoteи файлом /canine/types.txtсуществует. Кроме того, предположим, что /coyotesэто символическая ссылка в файловой системе, которая указывает на другой путь в файловой системе.
Таблица 9.3 isDirectory() ,isRegularFile(),isSymbolicLink()примеры
	isDirectory()	isRegularFile()	isSymbolicLink()
/canine/coyote	true	false	false
/canine/types.txt	false	true	false
/coyotes	true if the target is a directory	true if the target is a regular file	true

Вы видите, что значение isDirectory()и isRegular()в Таблице 9.3 нельзя определить по символической ссылке /coyotesбез знания того, на что указывает символическая ссылка.   
  Обработка исключений
При просмотре FilesAPI вы можете заметить, что isDirectory(), isRegularFile()и isSymbolicLink()не создавать исключение, если путь не существует, поэтому следующий код является избыточным:
if(Files.exists(path) && Files.isDirectory(path)) {
Этот код можно заменить одним Files.isDirectory()вызовом метода, так как exists()вызов не нужен:
if (Files.isDirectory (path)) {  
Проверка видимости файла с помощью isHidden ()
FilesКласс включает в себя Files.isHidden(Path)метод , чтобы определить , является ли файл или каталог скрыт в файловой системе. В системах на основе Linux или Mac это часто обозначается записями файлов или каталогов, которые начинаются с символа точки ( .), в то время как в системах на основе Windows это требует установки hiddenатрибута. isHidden()Метод бросков проверенного IOException, так как может быть ошибкой ввода / вывода считывания информации основного файла. Мы представляем иллюстративное использование этого метода в следующем примере кода:

try {   
System.out.println(Files.isHidden(Paths.get("/walrus.txt")));
} catch (IOException e) {   
// Handle file I/O exception...
}
Если walrus.txtфайл доступен и скрыт в файловой системе, этот метод вернется true.
Проверка доступности файлов с помощью isReadable () и isExecutable ()
FilesКласс содержит два метода для чтения файлов доступности: Files.isReadable(Path)и Files.isExecutable(Path). Это важно в файловых системах, где имя файла можно просматривать в каталоге, но у пользователя может не быть разрешения на чтение содержимого файла или его выполнение. Теперь приведем пример использования каждого метода:

System.out.println(Files.isReadable(Paths.get("/seal/baby.png"))); 
System.out.println(Files.isExecutable(Paths.get("/seal/baby.png")));
Первый пример возвращает, trueесли baby.pngфайл существует и его содержимое доступно для чтения, основываясь на правилах доступа базовой файловой системы. Второй пример возвращает, trueесли baby.pngфайл помечен как исполняемый в файловой системе. Обратите внимание, что расширение файла не обязательно определяет, является ли файл исполняемым. Например, файл изображения, который заканчивается, .pngможет быть помечен как исполняемый в системе на основе Linux.
Как isDirectory(), isRegularFile()и isSymbolicLink()методы, что isReadable()и isExecutable()методы не вызывают исключения , если файл не существует , но вместо того, чтобы вернуться false.  
Длина файла для чтения с размером ()
Files.size(Path)Метод используется для определения размера файла в байтах. Размер, возвращаемый этим методом, представляет концептуальный размер данных, и он может отличаться от фактического размера на устройстве постоянного хранения из-за сжатия и организации файловой системы. size()Метод бросает проверенный , IOExceptionесли файл не существует , или если процесс не может прочитать информацию о файле.
Ниже приведен пример вызова size()метода:

try {  
 System.out.println(Files.size(Paths.get("/zoo/c/animals.txt")));
} catch (IOException e) { 
  // Handle file I/O exception...
}
В примере выводится количество байтов в файле, выраженное как длинное значение. Как вы, возможно, уже поняли, мы повторяем множество методов, определенных в java.io.File, как обсуждалось в Главе 8. Поскольку API NIO.2 был определен как замена java.ioAPI, он включает в себя множество одинаковых методов в одной форме. или другой.
Files.size()Метод определен только на файлы. Вызов Files.size()в каталоге зависит от системы и не определен. Если вам нужно определить размер каталога и его содержимое, вам нужно пройтись по дереву каталогов, как описано далее в этой главе.
  Управление изменениями файлов с помощью getLastModifiedTime () и setLastModifiedTime ()
Большинство операционных систем поддерживают отслеживание последнего измененного значения даты / времени для каждого файла. Некоторые приложения используют это, чтобы определить, когда файл должен быть прочитан снова. Например, может существовать программа, которая выполняет операцию каждый раз, когда изменяются данные файла. В большинстве случаев гораздо быстрее проверить один атрибут метаданных файла, чем перезагрузить все содержимое файла, особенно если файл большой.
FilesКласс предоставляет метод Files.getLastModifiedTime(Path), который возвращает FileTimeобъект для достижения этой цели . FileTimeКласс представляет собой простой класс контейнера , который хранит дату / время информации о том, когда файл был доступен, изменены или создан. Для удобства в нем есть toMillis()метод, который возвращает время эпохи.
FilesКласс также обеспечивает механизм для обновления последнего изменения даты / времени файла с помощью Files.setLastModifiedTime(Path,FileTime)метода. У FileTimeкласса также есть static fromMillis()метод, который преобразует время эпохи в FileTimeобъект.
Оба эти метода имеют возможность бросить проверенный, IOExceptionкогда файл доступен или изменен.  
   Вам на самом деле не нужно изменять файл, чтобы изменить дату / время последнего изменения. Тем не менее, считается хорошей практикой изменять этот атрибут только при изменении данных файла, поскольку произвольное изменение этого значения может повлиять на приложения, которые регулярно обращаются к файлу.
Теперь представим примеры обоих методов:
try {  
 final Path path = Paths.get("/rabbit/food.jpg");   System.out.println(Files.getLastModifiedTime(path).toMillis());   
 Files.setLastModifiedTime(path,       
     FileTime.fromMillis(System.currentTimeMillis()));    System.out.println(Files.getLastModifiedTime(path).toMillis());
} catch (IOException e) { 
  // Handle file I/O exception...
}
Первая часть кода считывает и выводит последнее измененное значение времени food.jpegфайла. Следующая строка устанавливает дату и время последнего изменения, используя текущее значение времени. Наконец, мы повторяем нашу предыдущую строку и выводим недавно установленное последнее измененное значение даты / времени.
  Управление собственностью с помощью getOwner () и setOwner ()
Многие файловые системы также поддерживают понятие пользовательских файлов и каталогов. Таким образом, Files.getOwner(Path)метод возвращает экземпляр, UserPrincipalкоторый представляет владельца файла в файловой системе.
Как вы, возможно, уже догадались, существует также метод для вызова владельца, который вызывается Files .setOwner(Path,UserPrincipal). Обратите внимание, что операционная система может вмешаться, когда вы попытаетесь изменить владельца файла и заблокировать операцию. Например, процессу, выполняющемуся под одним пользователем, может быть запрещено принимать права собственности на файл, принадлежащий другому пользователю. Как getOwner()и setOwner()методы могут бросить проверяемое исключение IOExceptionв случае каких - либо вопросов , имеющий доступ или изменения файла.
Чтобы назначить владельца файла произвольному пользователю, API NIO.2 предоставляет UserPrincipalLookupServiceвспомогательный класс для поиска UserPrincipalзаписи для конкретного пользователя в файловой системе. Для того , чтобы использовать вспомогательный класс, сначала нужно получить экземпляр FileSystemобъекта, либо с помощью FileSystems.getDefault()метода или путем вызова getFileSystem()на Pathобъект , с которым вы работаете, как показано в следующих двух примерах:

UserPrincipal owner = FileSystems.getDefault().getUserPrincipalLookupService()    
                     .lookupPrincipalByName("jane");
 Path path = ...
UserPrincipal owner = path.getFileSystem().getUserPrincipalLookupService()         
                .lookupPrincipalByName("jane");

Приведем примеры таких getOwner()и setOwner()методов, в том числе , например , как использовать UserPrincipalLookupService:

try {  
 // Read owner of file  
 Path path = Paths.get("/chicken/feathers.txt");  
 System.out.println(Files.getOwner(path).getName());  
  // Change owner of file  
 UserPrincipal owner = path.getFileSystem()         .getUserPrincipalLookupService().lookupPrincipalByName("jane"); 
  Files.setOwner(path, owner);   
 // Output the updated owner information  
 System.out.println(Files.getOwner(path).getName());
} catch (IOException e) { 
  // Handle file I/O exception...
}
Первый набор строк читает владельца файла и выводит имя пользователя. Второй набор строк извлекает пользователя с именем janeв соответствующей файловой системе и использует его для установки нового владельца файла. Наконец, мы снова читаем имя владельца файла, чтобы убедиться, что оно обновлено. 
 Улучшение доступа с помощью представлений
До сих пор мы обращались к отдельным атрибутам файлов с помощью одного вызова метода. Хотя это функционально корректно, доступ к файлу часто сопряжен с расходами, которые значительно эффективнее извлекают все атрибуты метаданных файла за один вызов. Кроме того, некоторые атрибуты зависят от файловой системы и не могут быть легко обобщены для всех файловых систем.
API NIO.2 решает обе эти проблемы, позволяя вам создавать представления для различных файловых систем за один вызов метода. A view- это группа связанных атрибутов для определенного типа файловой системы. Файл может поддерживать несколько представлений, что позволяет вам извлекать и обновлять различные наборы информации о файле.
Если вам нужно одновременно читать несколько атрибутов файла или каталога, преимущество в производительности при использовании представления может быть существенным. Хотя считывается больше атрибутов, чем при одном вызове метода, количество циклов между Java и операционной системой меньше, тогда как для чтения тех же атрибутов с помощью ранее описанных вызовов одного метода потребуется много таких поездок. На практике количество поездок между Java и операционной системой важнее при определении производительности, чем количество прочитанных атрибутов.
Это не значит, что вызовы отдельных методов, которые мы только что закончили, не имеют своих приложений. Если вам нужно прочитать только один атрибут файла, то разница в производительности невелика. Они также имеют тенденцию быть более удобными для использования, учитывая их краткий характер.  
Понимание взглядов
Чтобы запросить представление, вам необходимо указать как путь к файлу или каталогу, чью информацию вы хотите прочитать, так и объект класса, который сообщает методу API NIO.2, какой тип представления вы хотите вернуть.
FilesAPI включает в себя два набора методов , аналогичных классов для доступа к информации просмотра. Первый метод, Files.readAttributes()возвращает доступное только для чтения представление атрибутов файла. Второй метод Files.getFileAttributeView()возвращает базовое представление атрибута и предоставляет прямой ресурс для изменения информации о файле.
Оба эти метода могут выдать проверенный IOException, например, когда тип класса представления не поддерживается. Например, попытка чтения атрибутов на основе Windows в файловой системе Linux может привести к UnsupportedOperationException.
В таблице 9.4 перечислены часто используемые атрибуты и классы представлений; Обратите внимание, что в первом ряду требуются знания для сдачи экзамена. Классы DOS и POSIX полезны для чтения и изменения свойств, специфичных для операционной системы. Они также оба наследуют от своих соответствующих атрибутов и классов представления. Например, PosixFileAttributesнаследуется от BasicFileAttributes, так же, как DosFileAttributeViewнаследует BasicFileAttributeView, означает, что все операции, доступные в родительском классе, доступны в соответствующих подклассах.
Таблица 9.4 Атрибуты и классы просмотра
Attributes Class
Класс атрибутов	VПосмотреть классiew Class	Описание
BasicFileAttributes	BasicFileAttributeView	Базовый набор атрибутов, поддерживаемый всеми файловыми системами
DosFileAttributes	DosFileAttributeView	Атрибуты, поддерживаемые системами на базе DOS / Windows
PosixFileAttributes	PosixFileAttributeView	Атрибуты, поддерживаемые системами POSIX, такими как UNIX, Linux, Mac и т. Д.

Для экзамена, вы должны быть знакомы с BasicFileAttributesи BasicFileAttributeViewклассов и их общих методов, таких как creationTime(), lastModifiedTime()и так далее. Вам не нужно запоминать методы , доступные к DosFileи PosixFileклассам для экзамена, хотя вы должны знать , что они существуют в случае , если вы столкнетесь с ними.  
Чтение Атрибутов
API NIO.2 предоставляет Files.readAttributes(Path,Class<A>)метод, который возвращает доступные только для чтения версии представления файла. Второй параметр использует обобщенные значения, так что тип возвращаемого значения метода будет экземпляром предоставленного класса.
BasicFileAttributes
Все атрибуты классов расширяются от BasicFileAttributes; поэтому он содержит атрибуты, общие для всех поддерживаемых файловых систем. Она включает в себя многие из атрибутов файла , которые вы уже видели , как метод однострочных вызовов в Filesклассе, например Files.isDirectory(), Files.getLastModifiedTime()и так далее.
Теперь мы представляем пример приложения, которое извлекает BasicFileAttributesиз файла и выводит различные метаданные о файле:

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
 public class BasicFileAttributesSample { 
  public static void main(String[] args) throws IOException { 
     Path path = Paths.get("/turtles/sea.txt");     
 BasicFileAttributes data = Files.readAttributes(path, 
   BasicFileAttributes.class);
System.out.println("Is path a directory? "+data.isDirectory());  
    System.out.println("Is path a regular file? "+data.isRegularFile());    
  System.out.println("Is path a symbolic link? "+data.isSymbolicLink()); 
     System.out.println("Path not a file, directory, nor symbolic link? "+    data.isOther());  

     System.out.println("Size (in bytes): "+data.size());  

     System.out.println("Creation date/time: "+data.creationTime());  
    System.out.println("Last modified date/time: "+data.lastModifiedTime());  
    System.out.println("Last accessed date/time: "+data.lastAccessTime()); 
     System.out.println("Unique file identifier (if available): "+          data.fileKey()); 
  }
}
Большинство из этих атрибутов должны быть вам знакомы, так как они были рассмотрены в предыдущем разделе этой главы. Только те , которые являются новыми являются isOther(), lastAccessTime(), creationTime(), и fileKey(). Этот isOther()метод используется для проверки путей, которые не являются файлами, каталогами или символическими ссылками, например путей, которые ссылаются на ресурсы или устройства в некоторых файловых системах. lastAccessTime()И creationTime()методы возвращают другую дату / время информации о файле. fileKey()Метод возвращает значение системного файла , который представляет собой уникальный идентификатор файла в файловой системе или , nullесли он не поддерживается файловой системой.  
Изменение атрибутов
Хотя этот Files.readAttributes()метод полезен для чтения данных файла, он не предоставляет прямого механизма для изменения атрибутов файла. API NIO.2 предоставляет Files.getFileAttributeView(Path,Class<V>)метод, который возвращает объект представления, который мы можем использовать для обновления атрибутов, зависящих от файловой системы. Мы также можем использовать объект представления для чтения связанных атрибутов файловой системы, вызывая readAttributes()объект представления.
BasicFileAttributeView
BasicFileAttributeViewиспользуется для изменения набора значений даты / времени в файле. В общем случае мы не можем напрямую изменять другие базовые атрибуты, так как это приведет к изменению свойства объекта файловой системы. Например, мы не можем установить свойство для изменения каталога в файл, так как это оставляет файлы в будущем в неоднозначном состоянии. Аналогично, мы не можем изменить размер объекта без изменения его содержимого.
Сейчас мы представляем пример приложения, которое считывает основные атрибуты файла и увеличивает последние значения даты / времени файла на 10 000 миллисекунд или 10 секунд:

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.*; 
public class BasicFileAttributeViewSample {
   public static void main(String[] args) throws IOException { 
     Path path = Paths.get("/turtles/sea.txt");  
     BasicFileAttributeView view =    
     Files.getFileAttributeView(path,BasicFileAttributeView.class);    
  BasicFileAttributes data = view.readAttributes();    
   FileTime lastModifiedTime = FileTime.fromMillis(      
   data.lastModifiedTime().toMillis()+10_000);  
     view.setTimes(lastModifiedTime,null,null);   
}
}
Обратите внимание, что хотя мы и вызывали Files.getFileAttributeView(), мы все же смогли получить BasicFileAttributesобъект, вызвав readAttributes()полученное представление. Поскольку setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)в BasicFileAttributeViewклассе есть только один метод обновления , и он принимает три аргумента, нам нужно передать три значения методу.
API NIO.2 позволяет нам передавать nullлюбое значение даты / времени, которое мы не хотим изменять. Например, следующая строка кода изменит только дату и время последнего изменения, оставив значения даты / времени в другом файле без изменений:
view.setTimes(lastModifiedTime,null,null);
